Useful Docs:
    * formating dates:   https://docs.djangoproject.com/en/2.0/ref/templates/builtins/#date
    * CoreyMSchafer Video Playlist: https://www.youtube.com/watch?v=aHC3uTkT9r8&list=PL-osiE80TeTtoQCKZ03TU5fNfx2UY6U4p&index=1

Note For using this file:
    1. $var indicates that var is a variable 
    2. all the code is enclosed in `` or ``` ``` tacs

-------------Creating the django project------------------

1. create Project ->#created the project using: `django startproject <project-name>`

2. run server-># ran the server using: `py manage.py runserver`

3. create app -> #created an app called "blog" using `python manage startapp <app-name>`

<blog/views.py> ->creating the actual views (basic)
    1. importing `HttpResponse` from `django.http` -->to send the httpResponse
    2. created a function called home that will return the httpResponse
    3. Now to add the route this will be managed by the blog/urls.py 


created <blog/urls.py>   -->this is where we will manage the urls within that app
    in <blog/urls.py>
        1. imported `path` from `django.urls`
        2.  imported the `views` in to this file
        3. added a new $urlpatterns list with 1st element as path("",views.home,name = "blog-home")

Now to specify which urls will route to our app "blog" 
    This is done in the main urls file..
    in <urls.py>
        1. imported `include` from `django.urls`
        2. added path("blog/",include("blog.urls"))  #when the url countains blog/ use the urls defined in blog/urls.py to further 
                route to the correct dest..

in<blog/urls.py and blog/view.py>
    1. added the about option.


Creating Admin/Users:
    first need to create a database for the project
    (more in database migrations )
        `py manage.py makemigrations`  -> detects changes and prepares django to update the database
        `py manage.py migrate`  ->creates the migrations?
        `py manage.py createsuperuser` ->creates the superuser (prompts)
    then you can go to the login page for the admin page



-----------Now Learning to use templates -------------------
1. Create a dir called "Template" in the "blog" dir

Creating the files that will be used as templates
    in <templates/>  
        1. create a subdirectory with same name as the app here "blog"  (overview ) blog -> templates -> blog
        in <templates/blog/>
            1. created "home.html" and "about.html"

Including the App Config
    Our Apps configurations are located in the `apps.py` file
    To use these configurations we must include this in the "apps definitions"
    To add the path to the appconfig class BlogConfig in "settings.py"
        in <setting.py>
            1. append `'blog.apps.BlogConfig'` in the $INSTALLED_APPS varible
            Here blog->appname ,apps -> "apps.py" ,BlogConfig ->class Name within "apps.py"

Rendering Templates 
    Now To render the templates in `views` from "blog/templates/<templatefile>"
    in <blog/views>
        1. redefine `home` function to return `render(request,"path-to-templatefile",< Any additional data to be used(Passing Data to template to be Rendered) >)
        2. similarly redefine the `about`

Passing Data to template to be Rendered
    Now Suppose you have a data (see an example below)
    To pass it in the template just pass it as a dict into `render()`
    in <blog/views>
        1. create $context :dict with a key `"posts"` and value `data`
        2. pass the $context in render() funtion

    Extacting Template Data
        
        int <blog/template/blog/home.html,blog/template/blog/about.html>
            1. use for loops and if statements to write data to the template..

Template Inheritance:(see "A Note on Template Inheritance")
    Instead of repeating code in templates just use template inheritance to make life easier    
    in <blog/template/blog>
        1. Create a "base.html" file 
        
        in <./base.html>
            1. create the basic structure of the html
            2. add a `block` (see rules) to the body section (this block will be over written by child Templates)
        
        in <./home.html>
            1. get rid of all code which is same as that of the "base.html"
            2. At the top declare the template as child template(see rules or see Note on Template inheritance)
            3. create the block to overwrite it and then overwrite it


Adding BootStrap (It's a HTML javascript CSS framework) Loading Static filess
    Download the basic template from bootstrap docs page
    Note Static files like js and css are stored in "static" dir
        1. in <blog/static/main.css>
            1. pasted from https://raw.githubusercontent.com/CoreyMSchafer/code_snippets/master/Django_Blog/03-Templates/django_project/blog/static/blog/main.css
        2. in <blog/template/base.html>
            1. load the static file (see rules) {% load static %} followed by 
            2. `{% static 'blog/main.css' %}` to import the statics 

A Note on Template Inheritance:
        We have something called a block 
        A block can be overwritten by child templates  
        We can have many nested block 
            1. To inherit the contents of a base.html declare   
                a. ` {% extends "path-baseHtmlFile-relative-to-template-path"%} ` at top
                b. create the actual block that you'll be overwriting..
            2. To show which part of the base.html will be used by chid templates to write their Data 
                a. declare a block  ` {% block <blockName> %}
                                        #block content 
                                      {% endblock %} `
            
Note on Database :
    1. ORM object relational Mapper
    2. using sqllite for development
    3. using postgressql for production?
    4. The database stucture can be represented as classes and these are called Models (so that's why we have model.py)
    5. Migrations are a way to restucture your database evenafter it has data in it without messing with the existing data
    6. Querying the database is also like interating with objects

Creating a database: 
    We're going to create a model named "Post"
    To do this:
        <in blog/models.py>
            1. create a new Class named "Post" that inherits from model class 
            The members of this class will represent the fields
            2. Create a $title and set it to  `models.CharField(max_length=100)`
            3. Create a $content and set it to `models.textField()`
            
            Now Import `from django.utils import timezone`
            timezone.now() is a function that gives the current datetime
            
            4. Create a $date_posted and set it to `models.DateTimeField(default = timezone.now)` 
                - Notice that we just passed the function(timezone.now) as the argument 
            
            We Also need the author for the post who will be the user himself/herself
            For that `from django.contrib.auth.models import User`
            Now The author and the post have a one_to_many relationship (one author can have many post but a post can only have one user)
            So we'll set the author to be a ForeignKey (remember a foriegn key is a primary key in another entity that is being refrenced in the current entity)
            
            5. create a $author and set it to `models.ForeignKey(User,on_delete = models.CASCADE)` 
            
            Now To create the migrations just type `py manage.py makemigrations`
            This will create and show the dir where the migrations was made here it will be "blog/migrations/0001_initial.py" file 

            6. Creating __str__(self) method to Print some proper info when querying

        To View the Sql Code:
            `py manage.py <appname> <migrationNumber>`
            IN OUR CASE : `py manage.py blog 0001`
        
        Now that we have created the database We must apply our migrations 
        
        To Apply Our migrations:
            `py migrate.py migrate`

Note on Database Querying:
    ``` from blog.models import Post                                                                    # importing the Post Table
        from django.contrib.auth.models import User                                                     #importing the User Table
        firstUser = User.objects.get(id=1)                                                              #get(<attribute-name> = <attribute-val>)  -> querySet[]
        alsoFirstUser = User.objects.first()                                                            #Returns the first User
        AllPosts = Post.objects.all()                                                                   #returns all the objects in the query set
        post_1 = Post(title="Blog 1",content = "The content of Blog 1",author = User.objects.first())   #creating a post
        post_1.save()                                                                                   #Saving the post
        ```


Fetching the data from the DB:
    <in blog/views.py>
        1. add `from .models import Post`   
        2. in the $context with key "posts" set it to Post.objects.all()
    Formatting the dates:
        <in blog/views.py>
            1.find {{date_posted}} and change it to `{{date_posted|date:"D d M Y"}}`
            Docs : https://docs.djangoproject.com/en/2.0/ref/templates/builtins/#date


Creating a User Registration form Using a new app names "users"
    1. Creating the `users` app and including it's config 
        1. `py manage.py startapp users`

        2. <in settings.py>:
                register our users app by adding `'users.apps.UserConfig'` to $INSTALLED_APPS

    Django has  a users creation form in the form of a class

    2. Creating the Userapp views to render the  Template used for registration
        1. <in users/views.py>
            1. add `from django.contrib.auth.forms import UserCreationForm`
            2. Add the register function that will handle the register request..
            in register function
                1. set `form = UserCreationForm`
                2. `return render(req,"users/register.html",{"form":form})`

        

    3. Now TO create the template for Registration..
        <in "users/template/users/register.html">
            1.  inherit from the "blog/base.html" using `{% extends "blog/base.html" %}`
            2.  create the block content.
                1. within the block content Create a div with `class = "content-section"`
                    1. within the div create a `form` tag.. with `method="POST"`
                    
                        we need to add a csrf_tokens cross-site-forgery-token for added security this is *required
                        1. csrf_token : `{% csrf_token %}

                        To group related elements we add a `fieldset` tag..

                        2. <fieldset class = "form-group"  

                            And a Legend to the form with a `border-bottom mb-4` bootstrap class

                            1. `<legend class = "border-bottom mb-4`>Join Today</legend>` 

                            Now the form.

                            2. `{{ form.as_p }}` to add the contents of the entire form in paragrah tag
                        
                        Now need to add the submit button.. 
                        This will be in a `div` with the `class="from-group"`
                        
                        3. `<div class = "form-group"> `
                            Now The Button.. with `type= "submit"` and bootstrap `class = "btn btn-outline-info"`

                            `<button class = "btn btn-outline-info" type = "submit" >Sign Up</button>
                2. Create a signin message using
                    1. a `div` with bootstrap `class = "border-top pt3"`
                        1. within it a  `small` tag.. with `class="text-muted`  -> "Already have an account?"
                        2. along with `a` tag `<a href =  "ml-2" href = "#"> Sign In</a>

    4. Now To add the Urls for register But directly to the project Setting 
        <in urls.py>
            1. in $urlpatterns add `path("register/",users_views.register,name= "register")` #basically url:"register/" Req Handled by: users.views.register Name = "register"

    5. Now to enable our register method to  validate the entered data and redirect if it is correct
        So when the user submits the data ..  by default the POST is done to the same url..
        So we have request.method = 'POST'
        `request.post` contains the posted data..
        This is passed to a new user creation form
        This `$form` object has a method `is_valid()` that checks the form for errors
        <in users/views.py>
            1. `from django.shortcuts import redirect`
            2. `from django.contrib import messages`  #remember to see how to enable the template to display the messages
            3. ```
                if request.method == "POST":
                    form  = UserCreationForm(request.POST)  # create a from with the post data
                    if form.is_valid():
                        from.save()   # create the user if valid user
                        username = form.cleaned_data["username"] # if the form is valid get username to show message
                        messages.success(request,f'Created Account for {username}')   # show a flash message 
                        return redirect("blog-home")   #redirect to homepage
                else: #get request
                    form = UserCreationForm()
                return render(request,"users/register.html",{"form":form})
               ```

    6. Now to enable the template (in the base template) to display flash messages: 
        <in blog/temlate/blog/base.html>
            
            We'll add this just above the content block..

            bootstrap has a alert class `class = "alert alert-<alert-type>"
            The $message in each $messages  has a `.tag` that specifies the type of the message passed
            So we make a `div` with `class = "alert alert-{{ message.tag }}
            then the actual message content within the div
            ```
                <!-- See if the template recieved any messages.. -->
                {% if messages %}  
                    <!-- Loop Through the messages -->

                    {% for message in messages %}
                        <div class="alert alert-{{ message.tag }}">
                            {{ message }}
                        </div>
                    {% endfor %}


                {% endif %}
            ```

    7. Extending the user model to be able to Add Profile pics..    
        Now  TO BE able to change the contents of the default `user creation form` that django provides we have to create a new class
        1. Create `users/forms.py`
        <in users/froms.py>
            1.  ```
                    from django import forms                                                # This is to specify the type of form fields
                    from django.contrib.auth.models import User                             # this is the model that our form will interact with
                    from django.contrib.auth.forms import UserCreationForm                  #this is what our from will inherit

                    class UserRegistrationForm(UserCreationForm):
                        email = forms.EmailField()                                          #adding fields is just adding variables

                        ##This is the meta class 
                        #It gives a nested namespace for the configurations
                        #It keeps the configurations in one place
                        class Meta:                     
                            model = User                                                    #The model that will be affected 
                            fields = ['username','email','password1','password2']           #The fields and their orders
                ```
        Now to use our registration form instead of UserCreationForm
        <in users/views.py>
            1. delete the `from django.contrib.auth.forms import UserCreationForm
            2. add `from .forms import UserRegistrationForm`
            3. replace all UserCreationForm with UserRegistrationForm
            
Making our forms "Crispy":
        crispy-forms are 3rd party lib that make   "crispy"forms (LOL)
        1. `pip install django-crispy-forms`
        
        <in setting.py>
            1. add to $INSTALLED_APPS `crispy_forms`
            2. At the end add `$CRISPY_TEMPLATE_PACK = 'bootstrap4'`
        
        Now to be able to use the crispy froms tags and filters we must load it first
        <in users/temlates/users/register.html>
            1. add `{% load crispy_forms_tags %}`
            2. replace  `{{forms.as_p}}`  with `{{ forms|crispy }}`

    Adding the login and Logout funtionality
        Since the views are  Already provided by django we directly add these in the `urls.py`
        <in urls.py>
            1. add `from django.contrib.auth import views as auth_views

            The auth_views contains the `LoginView` and the `LogoutView` as classes 
            The `as_view()` method is used to return a view..
            By default the login and the logout views that django provides look in the `registration/<template-name>.html`
            But by specifying the `template_name` in the `as_view()` method we can change it..
            ```
                path("login/",auth_views.LoginView.as_view(template_name = "users/login.html"),name = "login"), 
                path("logout/",auth_views.LogoutView.as_view(template_name = "users/logout.html"),name = "logout" )
            ```
        Templates For Login :
            1. create a new "users/template/users/login.html" file 
            
            <in "users/template/users/login.html">
                1. copy the template from the "users/template/users/register.html"
                2. replace `Sign Up!` button name with `Login`
                3. "Need and account to register"
                4. add the login `href = "{% url 'login' %}"` (Do the same in the register.html if you haven't)

            Now after login it redirects to /Accounts/profile To change that 
            
            <in setting.py>
                at the end add $LOGIN_REDIRECT_URL = "blog-home"

            Now after the user registers we want them to be redirected to the login page 

            <in users/views>
            
                1. in the register function change the message to `messages.success(request,f"Your account has been created You cannow Login!")`
                2. change redirect to `login`
            
            Now to add contents to logout.html
            <in users/template/users/logout.html>
                1. Add this:
                    ```
                    {% extends "blog/base.html" %}
                    {% block content %}
                        <h2 >You Have Been Logged Out</h2>
                        <div class="border-top pt-3">
                            <small class="text-muted">
                                <a href="{% url 'login' %}" >Log in again</a>
                            </small>
                        </div>
                    {% endblock content %}
                    ```
            Now Making the side navigation bar working..
                <in blog/template/blog/base.html>
                    1. add the hrefs to `{% url 'login' %}` and `{% url 'register' %}` for login and register text
                    
                    If the user is logged in the `user` object is available in the template with `user.is_authenticated` set to `True`

                    2. add a conditional if and else: 
                        ```
                        {% if user.is_authenticated %}
                        <a class="nav-item nav-link" href="{% url 'logout' %}">Logout</a>
                        {% else %}
                        <a class="nav-item nav-link" href="{% url 'login' %}">Login</a>
                        <a class="nav-item nav-link" href="{% url 'register' %}">Register</a>
                        {% endif %}

                        ```
            Now to add the profiles page:
                
                Adding Url path
                <in urls.py>

                    1. add `path("profile/",users_views.profile,name = "profile"), #adding the registration form`

                Adding the views
                <in users/views.py>
                    1. import the `from django.contrib.auth.decorators import login_required`decorator

                    2. add the  the function `profile` decorated with the decorator 

                    3. in the function body `return render(request,"users/profile.html")`
                
                Adding the template:
                    Now create a  file "users/template/users/profile.html"
                        1. add the necesary lines of code..
                            Note : If the user is logged in  the `{{ user }}` can be used to get the details
                            for Now just add the base template inheritance line  {% extends "blog/base.html %}
                            and the `<h2> {{ user.username }}</h2>`

                Now by default  the login url for django is "accounts/login"  to change this:
                    <in settings.py>
                        1. add $LOGIN_URL and set is to  `'login'`
    
Enabling the user to edit their profiles:
    1. Creating the profile Model
        1. We need to extend the User model
            Basically We'll create a new class that inherits the `models` class and has one to one correspondance with the `User` class
            Models that have one-to-one correspondance with other models will have fields with same name as the other pointing to that other model
            Meaning User <-> Profile  => <User>.profile points to the profile Model linked to User and  <Profile>.user  to the User..
            Notice that the field names start with small letter "<User>.profile"(correct) instead of "<User>.Profile" (incorrect)

            <in users/models.py>
                1. `from django.db import models`   # our Class will inherit the `models.Model` class
                2. `from django.contrib.auth.models import User`
                3. Create a class named    `Profile` ..
                    ```
                    Class Profile (models.Model):
                        user = models.OneToOneField(User,on_delete=models.CASCADE)                              ##Creting a one to one relationship to the User
                        image = models.ImageField(default = "default.jpg",upload_to = 'profile_pics')           ##An Image field with default = default.jpg and upload_to = <folderName>

                    def __str__(self):  #this will be used to display the class as str with proper info
                        return f'{self.user.username} Profile`'
                    ```
                    Here `user` is our one-to-one field that maps to User model and when it(`User`) is deleted the `Profile` is also deleted 

        2. Now to make changes to the db by running migrations 
            1. `py manage.py makemigrations`  to make th e migrations 
            2. `py manage.py migrate ` to run the migrations (actually update the database)

        3. Register this `Profile` models to the adminPage
            <in users/admin.py>
                ```
                    from .models import Profile
                    admin.site.register(Profile)
                ```
        
        4. Additional Info.
            4a. Adding new profiles from the admin page (Optional)
                1. Run the dev server and then go to "localHost:8000/admin" signIn with your admin account
                2. Click the profiles tab > ADD PROFILE 
                3. Add some image to your admin User
                4. Create a new Profile for another user and saveit without a profile pic (testing default.jpg)
            
            4b. Running the shell to learn a few things about the Profile
                1. Run the shell `py manage.py shell`
                2. import the `User` and `Profile`  classes
                3. create a $user = User.objects.first() 
                4. You'll find that since it is a one-to-one correspondance between a User and Profile,
                    You will be able to access the profile of the user by  `user.profile` (Notice the small 'p' in profile)  
                5. You can access the image by `user.profile.image` and this will return a `ImageFieldFile` object
                6. The default image Directory is the `"<appname>/<upload_to dir>/"`
                7. For duplicate images django automatically addson a hash value at the end..
        
        5. Changing the location where the images are saved
            <in setting.py>
                Django users the $MEDIA_ROOT to get the root directory for media files and $MEDIA_URL to 
                1. `MEDIA_ROOT = os.path.join(BASE_DIR,'media')` #this is the root where profile pcs are located..

                2. `MEDIA_URL = "/media/"`                          #public url for the images..

    2. Viewing the profile info and profile pics 
        1. Rendering the profile and profile pic in the template
            <in users/templates/users/profile.html>
                1. add the `div` with `class = content-section`
                    add the `div` with `class = "media"`
                        add `img` with `class = "rounded-circle account-img"`  This class is a bootstrap class (as you can probably tell)
                        add `h2` with `class ="account-heading"` 
                        add `p` with `class = "text-secondary"`  This is also a bootstrap class..
                    
            Read the docs.. `"https://docs.djangoproject.com/en/3.0/howto/static-files/#serving-files-uploaded-by-a-user-during-development"`

        2. serving static files
            Now to add the path to our media files So that wecan access them from the browser..
                    Here since we are still in dev mode. we can use the things as pointed out by above url..
                        <in urls.py>
                            ```
                                from django.conf.urls.static import static                             #This is to serve the static files in dev mode.. 
                                from django.conf import settings                                       #This is just importing the setting.py

                                #this is the way to serve static files in dev mode..only and thus the if block..
                                if settings.DEBUG:
                                    urlpatterns +=  static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 

                            ```
                            Description:
                                1. import `static` from `django.conf.urls.static` This will be used to serve static files but only in dev mode (mapping static files urls to their location)
                                2. import `settings` This is the config in `settings.py`
        
    See "Note on Django signals"

    3. Automating the profile Creation and Saving when a User is created using Signals..
        Create a new file in `users` app root dir  called `signals.py`       
            <in users/signals.py>
                1. import the `post_save` signal from `django.db.models.signals`
                2. import the `reciever` decorator form `django.dispatch`  .This is also where `Signal` class is located
                3. import the `User` model for the `django.contrib.auth.models`
                4. import the `Profile` model from `.models`
                5. Create a `create_profile` reciever function decorated by the `reciever` decorator.
                    ```
                        #when a signal is fired the appropriate data is passed as keywordArgs to the reciever functions (see docs )
                        @reciever(post_save,sender=User)                                    #We are connecting the post_save signal to Sender ->User
                        def create_profile(sender,instance ,created,**kwargs):              #When the signal is fired ,the create_profile method is invoked..
                            if created :
                                Profile.objects.create(user = instance)                     #Create a new profile with `{user:<instance of the User>  image:"default.jpg" }`  
                    ```
                6. We'll also create a `save_profile` reciever function
                    ```
                        @receiver(post_save,sender=User)
                        def save_profile(sender,instance,**kwargs):
                            instance.profile.save()
                    ```
    
        When using the `reciever` decorator the signals are  actually connected in the `ready` method of the `<app>Config class` in `"<appName>/apps.py"` file

        Connecting the recievers in `ready` method:
        <in users/apps.py>
            1. Create  a new Method ready:
                ```
                    def ready(self):
                        import users.signals
                ```

    4. Enabling the users Profile editing from the profiles page :

        1. Creating forms to update the `Profile` and the `User`
            1. Create 2 forms `ProfileUpdateForm` and `UserUpdateForm` both inheriting the forms.ModelForm
                1. for the `User`  model to edit  ["username","email"]
                    <in forms.py>
                        1. Create a  class `UserUpdateForm` inheriting the `forms.ModelForm`
                        2. add the extra `$email` field to the form 
                        3. Create the `Meta` class with `$model` set to User and `$fields` to `['username','email']`
                        ```
                            class UserUpdateForm(forms.ModelForm):
                                email = forms.EmailField()                                        
                                #The meta class
                                class Meta:                     
                                    model = User                                                    #The User model  will be affected 
                                    fields = ['username','email']                                   #The fields and their orders

                        ```

                2. for the `Profile` model to edit ["image"] :
                    <in forms.py>
                        1. Create a  class `UserUpdateForm` inheriting the `forms.ModelForm`
                        2. add the extra `$email` field to the form 
                        3. Create the `Meta` class with `$model` set to User and `$fields` to `['username','email']`
                        ```
                            class ProfileUpdateForm(forms.ModelForm):
                                #The meta class
                                class Meta:                     
                                    model = Profile                                                    #The User model  will be affected 
                                    fields = ['image']                                   #The fields and their orders

                        ```
        2. Creating the views for our `UserUpdateForm` and the `ProfileUpdateForm`:
            <in users/views.py>
                <in the `profile`  function>
                    1. `u_form = UserUpdateForm()`
                    2  `p_form = ProfileUpdateForm()`
                    3. `context = {'u_form':u_form,'p_form':p_form}`
                    4. `return render(request,"users/profile.html",context)`
        3. update the `profile.html`
            <in 'users/templates/users/profile.html'>
                1. add `{% load crispy_forms_tags %}` at the top
                2. add the `users/templates/users/register.html` section (copy the)
                    ```

                    <form method="POST" enctype="multipart/form-data">
                        <!-- csrf_token -->
                        {% csrf_token %}
                        <!-- Now the fieldset to group the elements together -->
                        <fieldset class="form-group">
                            <legend class = "border-bottom mb-4">Profile Info</legend>
                            {{ u_form|crispy }}
                            {{ p_form|crispy }}

                        </fieldset>
                        <div class="form-group">
                            <button type="submit" class="btn btn-outline-info">
                                Update
                            </button>
                        </div>
                    </form>
                
                Info :
                    1. So basically we have the `form` tag with the `POST` method. we need the `enctype` to be `"multipart/form-data"` to be able to passs in images.
                    2. The cross-site-forgery-token  `{% csrf_token %}`
                    3. The `fieldset` tag that holds the main form..
                        3a. The `legend` tag saying `"Profile Info"`
                        3b. `{{ u_form|crispy }}` and `{{ p_form|crispy }}` ie. the Update forms (`User` and `Profile`) rendered with the crispy forms..
                    4. The `div` tag containing our submit button

                            
                    ```
        4. Updating the `profile` views to be able to update the fields
            So if you run the dev server and go to the profile page.. you'll find that the fields are empty 
            1. What we would ideally like is to be filled up with the default values..
                To do this..   
                    1. We just need to pass the `request.user` and the `request.user.profile` instance  to the update forms 
                        The instance of the `User` will be available in the `$request` 
                        
                        1. `u_form = ProfileUpdateForm(instance =  request.user)`
                        2. `p_form = ProfileUpdateForm(instance =  request.user.profile)`
                    Info How does All this work.:
                        1. Both `UserUpdateForm` and `ProfileUpdateForm` inherit `ModelForm` and thus are a type of ModelForm
                        2. The ModelForms are displayed using `crispy_forms`.
                        3. What `crispy_forms` does is to check the `$fields` of the forms and display them.. Or (Probably) All fields except mentioned in the `$exclude`
                        4. When no instance of the `Model` is passed ,These fields are empty and when  we pass the instances of the Models the information is extracted from the `Model` instance is then displayed..
                        
                        Now the model associated with the `UserUpdateForm` is  `User` 
            The forms data will be posted using the `POST` request
            We need to be able to distinguish between the `GET`(while getting the profile ) vs `POST` (updating the profile.)
            This is similar to what we did in the `register` view
            2. To update the profile
                Just change the profile view to this..
                    ```
                        @login_required                                                                              #to ensure login is required to view this profile
                        def profile(request):                                                       
                            if request.method == 'POST':                                                                                     
                                u_form = UserUpdateForm(request.POST,instance = request.user) #
                                p_form = ProfileUpdateForm(
                                    request.POST,
                                    request.FILES,
                                    instance = request.user.profile)
                                if u_form.is_valid() and p_form.is_valid():
                                    u_form.save()
                                    p_form.save()
                                    messages.success(request,f"Your account has been Updated!")
                                    return redirect('profile')
                            else:
                                u_form = UserUpdateForm(instance = request.user) #
                                p_form = ProfileUpdateForm(instance=  request.user.profile)
                            context = {                                                          #creating the context dict to pass in values to the template..
                                'u_form':u_form,
                                'p_form':p_form

                            }
                            return render(request,"users/profile.html",context)
                    ```
                Info:
                    1. `@login_required` : decorator to ensure that the user is logged in to view the profile.. This automatically redirects the user to the login page..
                    2. `if request.method == 'POST':` :  If a `POST` request is made: 
                        1. `u_form = UserUpdateForm(request.POST,instance = request.user) ` : Create a `UserUpdateForm` passing in the `POST` data
                        2. `p_form = ProfileUpdateForm(request.POST,request.FILES,instance = request.user.profile)` : Create a ProfileUpdateForm passing in the `POST` data and the `FILES` data and the `instance` of the `Profile`
                                As you might have guessed we need to explicitly pass the files and the data an the instance of the model passed in the `POST` request to the `ModelForm` (here `ProfileUpdateForm`)
                        3. if both the forms ar valid :
                            1. Save both of them 
                            2. Add a flash message to say it's been completed..
                            3. redirect back to the same  `profile` page (`GET` request)
                    3. else:
                        simply create the two instances of the Update forms passing in the user and the profile instances..
                    4. Create  a dict named `context` and pass in the two forms..
                    5. Render the template `"users/templates/users/profile.html"`..
            3. Resizing the profile pics:
                We need to do this in the `users/models.py`
                <in users/models.py>
                    1. add `from PIL import Image` : Importing the Image 
                    2. override the save method in Profile class
                        ```
                            def save(self):
                                super().save()
                                img = Image.open(self.image.path)
                                if img.height>300 or img.width>300:
                                    outputSize = (300,300)
                                    img.thumbnail(outputSize)
                                    img.save(self.image.path)
                        ```
                    Info:
                        1. calling the super().save()  ~~//~~
                        2. opening the image path is `self.image.path` 
                        3. changing the image if it  is larger than 300px
                        4. `img.thumbnail(size)` maintains the aspect ratio of the image..
        5. managing the old image files..:
            when you upload a new image the old one is still stored on the fs
            To automatically delete it ..we'll use django-cleanup
            1. `pip3 install django-cleanup`
            2. add it under `$INSTALLED_APPS` in `settings.py` file
    5. Displaying the images in the blog-home  
        <in blog/templates/blog/home.html>
            1. add  `<img class = "rounded-circle article-img" src="{{ post.author.profile.image.url}}">` just below the `article` tag        
                    
Adding the posts to the homepage of the user
    Using class based views:
        Django has several generic views
        We'll be using `ListView`
        1.Creating the class `PostListView`
            <in blog/views.py>
                1. `from django.views.generic import ListView`
                2. Create the class :
                        ```
                            class PostListView(ListView):
                                model = Post                                #The model that will be used    
                                template_name = "blog/home.html"            #telling it where to look for our template
                                context_object_name = 'posts'
                                ordering = ['-date_posted']                 #Changing the order in which the posts are displayed newestToOldest
                        ```
                Info:
                    1. Here PostListView is  a user defined class inheriting from the `ListView` which is (one of many) generic view(s) in django
                    2. Every generic view has a model variable which must be set to the model that the view will be interacting  with (querying)
                    3. In order to return a view from the this class based view we must use `<className>.as_view()` method 
                    4. Every generic class-based "looks"  for a template of a specific name by default 
                        Pattern for the template that django looks for :  `<app>/<model>_<viewtype>.html`
                        Of course we can change the template that it should look for using the `$template_name` 
                            within the class definition : set `template_name = <your template file path>`

                    5. By default the data from the database is contained  in a dictionary under the key `objectList` 
                        This can be changed to any other name by using the `context_object_name = <yourVarName>`
                    6. An `ordering` attribute can be added to the content based on a particular `key` to order the content based on the key
                        Here `['-date_posted']` the `-(minus sign)` before the key value is to reverse the order    

                            
        2. Setting the app to use this view instead of the function based views that we created earlier
            <in blog/urls.py>
                1. import the `PostListView`:
                    add `from .views import PostListView` 
                2. replace the `views.home` to `PostListView.as_view()`
        
        3. Adding the ablility to view individual posts
            1. Creating The views.. (class-based)(also sticking to the django conventions)
                <in blog/views.py>
                    1. `from  django.views.generic import DetailView`
                    2. Create the class `PostDetailView` inheriting the `DetailView`
                    3. The class:
                        ```
                            class PostDetailView(DetailView):
                                model = Post

                        ```
            2. Setting the appropriate url:
                <blog/urls.py>
                    1. import the `PostDetailView` 
                        add `from .views import PostDetailView`
                    2. add `path('post/<int:pk>',PostDetailView.as_view(),name ='post-detail')`
                        
                    Info: 
                        1. Here the <int:pk> specifies that grab the object by the primaryKey which is int datatype of the model and use that to select the model
                        2. Since we didn't specify the primaryKey by default it is created under the column `id`
            3. Creating the template :
                1. Create a new file "blog/post_detail.html"            (remember the convention `<app>/<model>_<viewtype>.html`)
                2. <in "blog/post_detail.html" >
                    1. add the following code:
                        ```
                            {% extends "blog/base.html" %}
                            {% block content %}
                                <article class="media content-section">
                                    <img class="rounded-circle article-img" src="{{ object.author.profile.image.url }}">
                                    <div class="media-body">
                                        <div class="article-metadata">
                                            <a class="mr-2" href="#">{{ object.author }}</a>
                                            <small class="text-muted">{{ object.date_objected|date:"M d, Y" }}</small>
                                        </div>
                                        <h2 class="article-title" >{{ object.title }}</h2>
                                        <p class="article-content">{{ object.content }}</p>
                                    </div>
                                </article>
                            {% endblock content %}
                        ```
                    Info :
                        1. Notice that we use the var name `object` to access the object passed this is the django convention
            4. Linking the page from the homepage :
                <in home.html>
                    1. under the `h2` with `class="article-title" change the `href` from `"#"` to `"{% url 'post_detail'` Like this:
                         `<h2><a class="article-title" href="{% url 'post-detail' post.id %}">{{ post.title }}</a></h2>`
                        Info:
                            1. we named (in `"blog/urls.py"`) the url pointing to the  `"blog/template/blog/post_detail.html"` template file to `"post-detail"`
                            2. There we  replace the `<int:pk>` with our primaryKey `post.id`
        4. Adding the ability to Create new Posts:
            1. Creating the Views (using generic `CreateView`)
                <in "blog/views.py"
                    ```
                        class PostCreateView(CreateView):
                            model = Post
                            fields =['title','content']                             #we'll be editing the following fields while creating the model
                    ```
            2. Creating the urls path:
                <in 'blog/urls/.py'>
                    1. import the `PostCreateView`
                    2. add a new path:
                        `path('post/new/',PostCreateView.as_view(),name = 'post-create')`
            3. Creating the template:
                1. create a blog template file `"post_form.html"`
                <in blog/templates/blog/post_form.html dir>
                    1. Insert this code:
                        ```
                            {% extends "blog/base.html" %}                                          
                            {% load crispy_forms_tags %}
                            {% block content %}
                                <div class = "content-section">
                                    <form method="POST">
                                        <!-- csrf_token -->
                                        {% csrf_token %}
                                        <!-- Now the fieldset to group the elements together -->
                                        <fieldset class="form-group">
                                            <legend class = "border-bottom mb-4">Blog Post</legend>
                                            {{ form|crispy }}
                                        </fieldset>
                                        <div class="form-group">
                                            <button type="submit" class="btn btn-outline-info">
                                                Post
                                            </button>
                                        </div>
                                    </form>
                                </div>
                                
                            {% endblock content %}
                        ```
                        Code Explained:
                            1. Template inheritance pointing to the base template
                            2. Loading the `crispy_forms` application 
                            3. The block content that will be replaced with the data
                        

                    Info:
                        1. django expects the name to be `post_form.html` instead of `post_create.html` this is because this template is shared with `UpdateViews`
                        2. The key where the data is stored is `"form"`  
            4. Overriding the `formValid` method    
                    <in blog/views>
                        1. In `PostCreateView` class
                            1. add Code:
                                ```
                                    def form_valid(self,form):
                                        form.instance.author = self.request.user    #add the author as this user
                                        return  super().form_valid(form)            #validate the form
                                ```
                        Info:
                            1. `form_valid` method is used to validate the from
                            2. Here we are overriding this method(cuz this class is a inherited class ) with our own function that adds the author 
                            3. Then return the original(the one defined in the `CreateView` (parent) class) `form_valid` method
                            4. After the form is validated it actually tries to redirect to a `url_success`
                            5. But in the `CreateView` and `UpdateView` it simply uses the `get_absolute_url` method on the model
                            6. If you want you can create a var `success_url` in the class attribute and this is where it will redirect after creating the post (you have to use `reverse_lazy method`)
                            7. Thus we need to Create a `get_absolute_url` method for our Post class

                2. Creating the `get_absolute_url` method for the `Post` model
                    <in blog/models.py>
                        In the `Post` class 
                            1. import the `reverse` function from `django.urls` 
                            2. add a method `get_absolute_url` Code:
                                ```
                                    def get_absolute_url(self):
                                    return reverse('post-detail',kwargs = {'pk':self.pk})
                                ```
                        Info:
                            1. We are using the `reverse` instead of `redirect` This simply returns the full path to the link as a string rather than actually redirecting it 
                            2. The redirecting will be handled by the `forms_valid` method in the `CreateView` class that we created earlier
                            3. `"post-detail"` is the name of the url 
                            4. remember the url expects a kwarg `"<int:pk>"` so we pass it as kwargs and value is the `self.pk` which is the primaryKey of the model (here `id`)
            5. Create posts only on login:
                <in blog/views.py>
                    1. import the `LoginRequiredMixin` from `django.attrib.auth.mixins`
                    2. inherit this class first before other classes (here `CreateView`) in the `PostCreateView` 
                Info:
                    1. for function based views we used the `@login_required` decorator 
                    2. But for class based views we can do the same by inheriting from `mixins`
        5. Update existing posts:
            1. creating the view:
                <in blog/views>
                    1. import the `UpdateView` from `django.views.generic`
                    2. create the class similar to the `PostCreateView` class
                    3. replace the class name to `PostUpdateView`
                    4. change the inherted class `CreateView` to UpdateView
                    Done!
            2. Adding the url route 
                <in blog/urls.py>
                    1. import the `PostUpdateView`  from `.views` 
                    2. add the following `path('post/<int:pk>/update/',PostUpdateView.as_view(),name = 'post-update'),   `
                Info:
                    1. Notice the url path 
            3. Make sure only the author of the post can edit it
                If you actually login you can edit posts created by other users .We don't want this
                1. import the `UserPassesTestMixin` from   `django.contrib.auth.mixins`
                2. inherit the `UserPassesTestMixin` class in the `PostUpdateView`  before the  `UpdateView`
                3. override the `test_func` 
                    ```
                        def test_func(self):
                            post =  self.get_object()                       #get the post as an object
                            return  self.request.user == post.author        #make sure the requested user matches the posts.author

                    ```
        6. Delete Posts:
            1. Creating the view:
                <in urls/views.py>
                    1. Create the `PostDeleteView`  class 
                        ```
                            class PostDeleteView(LoginRequiredMixin, UserPassesTestMixin,DetailView):
                                model = Post 
                                def test_func(self):
                                    post =  self.get_object()
                                    return  self.request.user == post.author
                                

                        ```
            2. Addind the url path
                <in blog/urls.py>
                    1. `path('post/<int:pk>/delete/',PostDeleteView.as_view(),name = 'post-delete')`
            3. Creating the confirm delete form
                Create a template file "post_confirm_delete.html" 
                <in blog/templates/blog/post_confirm_delete.html>
                    1. Paste the following 
                        ```
                                {% extends "blog/base.html" %}
                                {% block content %}
                                    <div class = "content-section">
                                        <form method="POST">
                                            {% csrf_token %}
                                            <fieldset class="form-group">
                                                <legend class = "border-bottom mb-4">Delete Post</legend>
                                                <h2 >Are You sure you want to delete the Post "{{object.title}}"</h2>
                                            </fieldset>
                                            <div class="form-group">
                                                <button type="submit" class="btn btn-outline-danger">
                                                    Yes,Delete!
                                                </button>
                                                <a class  = 'btn btn-outline-secondary' href = "{% 'post-detail' `object.id
                4.  %}">Cancel</a> (using classed based views this is what django gives the var name to be accessible in the template (`object`) for a `DetailView`
                                            </div>
                                        </form>
                                    </div>
                                    
                                {% endblock content %}

                        ```
                    Info:
        7. Linking it all up:
            <in blog/templates/blog/base.html>
                1. Add an `a` tag pointing to the `"post-create"` link  just below the `{% if user.is_authenticated %}` line (in the navigation bar)
                    `<a class="nav-item nav-link" href="{% url 'post-create' %}">New Post</a>` 
            <in blog/templates/blog/post_detail.html>
                1. add The following  at the end of `div` with `class = 'article-metadata'`
                    ```
                        {% if object.author == user %}
                            <div>
                                <a class="btn btn-secondary btn-sm mt-1 mb-1" href="{% url 'post-update' object.id %}">Update</a>
                                <a class="btn btn-danger btn-sm mt-1 mb-1" href="{% url 'post-delete' object.id %}">Delete</a>
                            </div>
                        {% end if %}
                    ```
                Info :
                    1. if the user is same as the author of the post show update 
                    2. The bootstrap class:
                        for Logout: a button , secondary-button , small-button , top-margin:1,bottom-margin-1
                        for Delete: a button , button-danger , small-button , top-margin:1,bottom-margin-1
                    3. url `"post-update"` which expects a `pk`  that is stored in `object.id` 
                    4. using classed based views this is what django gives the var name to be accessible in the template (`object`) for a `DetailView`
Paginating our pages:
    1. set the `paginate_by` atttribute in the  class based views
        <in blog/view.py>
            In the class `PostListView`
                1. add `paginate_by = 5` This will show five posts per page..
                2. To access the page using url go to `<currentUrl>/?page=<next_page_number>`
    2. adding the pagination link in the Home page:
        <in blog/templates/blog/home.html>
            1.  add the following code.
                ```
                    {% if is_paginated %}

                        {% if page_obj.has_previous  %}
                            <a class= "btn btn-outline-info mb-4" href="?page=1">First</a>
                            <a class= "btn btn-outline-info mb-4" href="?page={{ page_obj.previous_page_number }}"> Previous </a>
                        {% endif %}

                        
                        {% for num in page_obj.paginator.page_range %}
                            {% if page_obj.number == num  %}
                                <a class= "btn btn-info mb-4" href="?page={{ num }}">{{ num     }}</a>
                            {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3'  %}
                                <a class= "btn btn-outline-info mb-4" href="?page={{ num }}"> {{ num }}</a>
                            {% endif %}
                        {% endfor %}


                        {% if page_obj.has_next  %}
                            <a class= "btn btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>
                            <a class= "btn btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last </a>
                        {% endif %}

                    {% endif %}
                ```
            Info :
                1. by default when rendering templates using the class based view if  the pagination is active `is_paginated` is set to `True`
                2. The page object is passed in as `page_obj` inside the template
                3. `add` is one of the filter that add a num and returns the result 
                4. See "Note on pagination" for more details

Filter posts by user :
    1. Creating the view :
        <in blog/views.py >
            1. add 
                ```
                    from django.contrib.auth.models import User
                    from django.shortcuts import get_object_or_404                                      #this will return the user if it exists else return 404

                    class UserPostListView(ListView):
                        model = Post
                        template_name = "blog/user_posts.html"                                          ##What model that   we need to query
                        context_object_name = "posts"
                        paginate_by = 5 

                        def get_queryset(self):                                                         #we are overriding this method so that we can return our own queryset
                            user =  get_object_or_404( User , username= self.kwargs.get('username'))
                            return  Post.objects.filter(author = user).order_by('-date_posted')

                ```
            Info:
                1. This will be same as that of the `PostListView` class
                2. The `model` used is `Post`
                3. We change the template name to  `"blog/user_posts.html"` (we'll Create this next)
                4. Paginating 5 posts per page..
                5. We need to override the `get_queryset` method to return the filtered querySet by username
                6. we are using the `get_object_or_404` method from the `django.shortcuts` to get the object if it exists else return 404 Page
                7. If it is a success  filter the `Post` objects  by  the username 
                8. notice that the ordering is done not by the class attribute `ordering` but by using `<querySet>.order_by`
                9. In the `get_object_or_404` method notice we use `self.kwargs.get('username')`
    2. Creating the route..:
        <in blog/urls.py>
            1. import the `UserPostListView` class from  `.views`
            2. add :
                    `path('user/<string:username>', UserPostListView.as_view(),name = 'user-posts'),`
    3. Creating the template:
        Create a new file `"blog/template/blog/user_posts.html "`
            <in user_posts.html>
                1. add this (similar to `home.html`)
                    ```
                        {% extends "blog/base.html" %}
                        {% block content %}
                            <h1 class = "mb-3">Post by {{ view.kwargs.username }} ({{ page_obj.paginator.count}})</h1>
                            {% for post in posts %}
                                <article class="media content-section">
                                    <img class = "rounded-circle article-img" src="{{ post.author.profile.image.url}}">
                                    <div class="media-body">
                                        <div class="article-metadata">
                        <!-- Here we are passing the username to the url as a param  -->
                                            <a class="mr-2" href="{% url 'user-posts' post.author.username %}">{{ post.author }}</a>            
                                            <small class="text-muted">{{ post.date_posted|date:"M d, Y" }}</small>
                                        </div>
                                        <h2><a class="article-title" href="{% url 'post-detail' post.id %}">{{ post.title }}</a></h2>
                                        <p class="article-content">{{ post.content }}</p>
                                    </div>
                                </article>
                            {% endfor %}


                        <!-- Pagination -->
                            {% if is_paginated %}

                                {% if page_obj.has_previous  %}
                                    <a class= "btn btn-outline-info mb-4" href="?page=1">First</a>
                                    <a class= "btn btn-outline-info mb-4" href="?page={{ page_obj.previous_page_number }}"> Previous </a>
                                {% endif %}

                                
                                {% for num in page_obj.paginator.page_range %}
                                    {% if page_obj.number == num  %}
                                        <a class= "btn btn-info mb-4" href="?page={{ num }}">{{ num     }}</a>
                                    {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3'  %}
                                        <a class= "btn btn-outline-info mb-4" href="?page={{ num }}"> {{ num }}</a>
                                    {% endif %}
                                {% endfor %}


                                {% if page_obj.has_next  %}
                                    <a class= "btn btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>
                                    <a class= "btn btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last </a>
                                {% endif %}

                            {% endif %}
                        {% endblock content %}
                    ```
                Info : (How does it all fit together?)
                    1. 
                    
                    2. In the line below the comment   `<!-- Here we are passing the username to the url as a param  -->`
                        a. We defined in the `urls.py` :
                            `path('user/<string:username>', UserPostListView.as_view(),name = 'user-posts'),`
                        b. Here the url expects a parameter by name `"username"`
                        c. In the `views.py` we defined :
                            `user =  get_object_or_404( User , username= self.kwargs.get('username'))`
                        d. Here `self.kwargs.get('username')` gets the  `'username' kwarg` passed to the view from the url
                        e. So when you go to `"user/abc"`
                            1. Then the particular view gets called (here `UserPostListView.as_view()`) as according to the definition in the `path` in `urls.py` (after a particular url Pattern matches)
                            2. Here the kwarg 'username' recieved from the url is passed in and is available in the `kwargs` var inside the class
                            3. The `get_object_or_404` method get the username passed in the url from the `self.kwargs.get('username')` and searches with that attribute(`username="abc"`) in the `User` model's objects
                            4. if not found redircts to  a  404 page (I think)
                            5. else if found it returns the posts filtered by the attribute (`author="abc"`) in the `Post` model using the `.filter` method
                                6. The view then passes this info including the `kwargs` as `view.kwargs` to the template
                                7. The template uses `{{ view.kwargs.username }}` to access the username passed into it from the view
                                8. Since the pagination is active the `{{ page_obj }}` is also passed in the template (and ofcourse `is_paginated` is set to `True`)
                                9. The `{{ page_obj.paginator.count }}`  returns the total number of objects available (posts) 


    4. Now to activate the user posts links:
        We have to activate the links in the `home.html` and `post_detail.html` files  in the dir :`blog/templates/blog/`
            1.  <in home.html>
                replace the `"#"` sign  to `"{% url 'user-posts' post.author.username %}"` Like this  in post.author link
                    `<a class="mr-2" href="{% url 'user-posts' post.author.username %}">{{ post.author }}</a>`
            2. <in post_detail.html>
                replace the `"#"` sign  to `"{%url 'user-posts' object.author.username %}"` Like this  in post.author link
                    `<a class="mr-2" href="{%url 'user-posts' object.author.username %}">{{ object.author }}</a>`
                
                
Note on Django signals...
    
    Docs: https://docs.djangoproject.com/en/3.0/topics/signals/

    Django signals are a sent by "senders" to notify "recievers" that a certain "action" has taken place
    Eg. 1. pre_save                                 -> called before model is saved         
        2. post_save                                -> called after  model is saved     
        3. request_started and request_finished     -> Sent when Django starts or finishes an HTTP request.
        4. pre_delete                               -> called  before a model is  deleted    
        5. post_delete                              -> called after a model is  deleted    
        6. m2m_changed etc..                        -> called after a ManyToManyField in a model is changed..  
    Recievers..
        To "listen" to signals we need recievers..
        recievers are functions or method that are "connected" to a signal and are called once they recieve the signal..
        Two ways to connect reciever functions/methods to signals..
            1. `Signal.connect()`
                <signalName>.connect(<callbackFunction>)
            2. `reciever` Decorator

                `receiver(signal)[source]`

                Eg.:A reciever function `save_profile` connected to a signal `post_save` that emanates from source `User`
                    ```
                        @receiver(post_save,sender=User)
                        def save_profile(sender,instance,**kwargs):
                            instance.profile.save()
                    ```
                
                Note while using the decorator method: 
                    you must import the signals submodule under the `ready()` method of `<appName>Config` class located in the `"<appName>/apps.py"` file


Note on Generi class based views
    list of views:
        1. ListView #use

Note on pagination :
    ```
        In [2]: from django.core.paginator import Paginator

        In [3]: post  = list("12345")                               #dummy objects list

        In [4]: post
        Out[4]: ['1', '2', '3', '4', '5']

        In [5]: p = Paginator(post,2)                               #divide the list into 2 per page

        In [6]: p.num_pages                                          #Total No of pages
        Out[6]: 3
        
        In [7]: for page in p.page_range:                           #page page_range attribute
        ...:     print(page)
        ...: 
        1
        2
        3

        In [8]: p1 = p.page(1)                                      #getting specific pages

        In [9]: p1
        Out[9]: <Page 1 of 3>

        In [10]: p1.number                                           #getting it's number       
        Out[10]: 1

        In [13]: p1.object_list                                      #getting it's content 
        Out[13]: ['1', '2']

        In [14]: p1.has_previous()                                   #check if it has prev of next 
        Out[14]: False

        In [15]: p1.has_next()
        Out[15]: True

        In [16]: p1.next_page_number                                  #get the next page number 
        Out[16]: <bound method Page.next_page_number of <Page 1 of 3>>

        In [17]: p1.next_page_number()
        Out[17]: 2
        
        In [22]: p3 = p.page(3)

        In [24]: p3.next_page_number()                                                          #exception when trying to access invalid page
        ---------------------------------------------------------------------------
        EmptyPage                                 Traceback (most recent call last)
        <ipython-input-24-6d710f7d200b> in <module>
        ----> 1 p3.next_page_number()
    ```

# Bonus : 
    1. Creating a remote github repo using github-api
        to create a github remote repo use `curl -u "<username>:pass" https://api.github.com/user/repos/ -d '{"name" = "<project-name>",<Other optional params>}'
    2. Split up multiple imports using `()` 
        eg:
            ```
                from foo import (
                    bar1,
                    bar2,
                    bar3
                )
            ```


///An example for data (passing data to templates)
    posts = [

        {

            'author': 'CoreyMS',

            'title': 'Blog Post 1',

            'content': 'First post content',

            'date_posted': 'August 27, 2018'

        },

        {

            'author': 'Jane Doe',

            'title': 'Blog Post 2',

            'content': 'Second post content',

            'date_posted': 'August 28, 2018'

        }
    ]

//Rules for working with Templates
    Rules:
            1. for Loops:   {%for var in vars%}
                                #body of the for loop
                            {%endfor%} 
            2. varibles:   {{varName}}

            3. Block:       {% block <blockName> %}
                                #block content 
                            {% endblock %}
            4. Template inheritance : {% extends "path-baseHtmlFile-relative-to-template-path"%} 
                            Note: Should be declared at the top of the child template
            5. Loading Static file :
                                    1. `{% load static %}`   # to load the static file 
                                    2. `href = {% static '<appname>/<staticfileName>'%}`  #to include the static file 


Dabase Related Commands:
    1. running shell : `py manage.py shell`
    2. Querying:
            1. importing the users :                `from django.contrib.auth.models import User`
            2. importing Our Own Entities:          `from <appname>.models import <entity-name>
            3. First entry in an entity:            `<entity-name>.objects.first()`                             #similarly last
            4. All entries:                         `<entity-name>.objects.all()`                               #returns a querySet    
            5. adding new Entity:                   `<entity-name>(<attributes = "<values>").save()`            Creates a new entry in the <entity-name> table
            6. Get:                                 `<entity-name>.objects.get(<attrib> = "<value>")
            7. Filter                               `<entity-name>.objects.filter(<attrib= "<value>")           #search by attrib ->queryset
            8. Getting data of oneobject from another object of another (related)entity
                    all posts of User:              `<user-object>.post_set.all()`
                    create:                         `<user-object>.<related-entity-name>_set.create(attribs)`    
            
Directory Structure :
    C:.
    .vscode                                                         #vscode config
    
    django_project                                                  #main project dir 
           db.sqlite3                                                      #The sqllite db file
           manage.py                                                       #this is what manages the enire project
        
        blog                                                        #The apps folder    
              admin.py                                                     #this is where we register our models that our admin can change using the GUI
              apps.py                                                      #The apps configurations file 
              models.py                                                    #This is where we create our entities
              tests.py                                                     
              urls.py                                                      #The urls within the app are defined here 
              views.py                                                     #This is where we render our templates
              __init__.py 
           
           migrations
                  __init__.py
           
           static                                                   #The Static folder(For Js and Css)
              blog                                                    #The App name
                      main.css                                                #The Css file for the app
           
           templates                                                #Templates Folder To store the templates
               blog                                                    #The appname
                       about.html                                              #about.html for the "blog" app
                       base.html                                               #Base Template for "blog" app
                       home.html                                               #home.html for "blog" app
           
        django_project                                                      #This is the folder where the project-wide settings are located
                asgi.py 
                settings.py                                                         #settings for the entire project
                urls.py                                                             #project urls redirects
                wsgi.py                                                             #file to configure the wsgi server
                __init__.py            

Directory Structure :
    django_project:.                                                     #main project dir 
           db.sqlite3
           manage.py                                                       #this is what manages the enire project
           README.md                                                       # readme File
    
    .vscode                                                          #vscode settings
           settings.json
    
    blog                                                        #The blog app   
          admin.py                                                     #this is where we register our models that our admin can change using the GUI
          apps.py                                                      #The apps configurations file 
          models.py                                                    #This is where we create our entities
          tests.py                                                     
          urls.py                                                      #The urls within the app are defined here 
          views.py                                                     #This is where we render our templates
          log.txt                                                      # THIS FILE
          __init__.py
       
       migrations                                              # This is where the migrations are saved
              0001_initial.py                                         This is this first saved migration
              __init__.py
       static                                                  #The Static folder(For Js and Css)
          blog                                                    #The App name
                  main.css                                                #The Css file for the app
       
       templates                                               #Templates Folder To store the templates
           blog                                                    #The appname
                   about.html                                              #about.html for the "blog" app
                   base.html                                               #Base Template for "blog" app
                   home.html                                               #home.html for "blog" app
    
    django_project                                               #This is the folder where the project-wide settings are located
           asgi.py 
           settings.py                                                 #settings for the entire project
           urls.py                                                     #project urls redirects
           wsgi.py                                                     #file to configure the wsgi server
           __init__.py            
    
    media                                                         #This is where the media files  are stored                                           
          default.jpg                                                     #The default user profile pic
       
       profile_pics                                                    #This where the profile pics of users are saved
               WIN_20200312_19_07_41_Pro.jpg                                   #An example
    
    users                                                          #The users app folder (handles the users and their profiles)
           admin.py                                                        #this is where we register our models that our admin can change using the GUI (same as that of the blog app)
           apps.py                                                         #The apps configurations file 
           models.py                                                       #This is where we create our entities
           tests.py                                                        
           urls.py                                                         #The urls within the app are defined here 
           views.py                                                        #This is where we render our templates        
           forms.py                                                        #This is where the user creation form along with other forms is located 
           signals.py                                                      #This is where the signal reciever functions that automate profile Creation are defined
           __init__.py
        
        migrations                                                  #The migrations folder for the users app
               0001_initial.py                                             #First migration for users app
               __init__.py
        
        templates                                                   #This is where the templates for user and profile related templates are stored
            users       
                    login.html                                               #The Login Template (uses crispy forms)  
                    logout.html                                              #The Logout template
                    profile.html                                             #The Users Profile template 
                    register.html                                            #The Users SignUP template (uses the Usercreation form located in users/forms.py)